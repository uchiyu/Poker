//====================================================================
//  工学部「情報環境実験２」(富永)  C言語プログラミング  例題
//  ポーカーゲームの戦略
//--------------------------------------------------------------------
//  Poker  PokerOpe.c
//  WinXP DOS  Borland C/C++ 5.5
//--------------------------------------------------------------------
//  安藤研究室 s13t208 内山豊
//  2015.11.10
//====================================================================


//====================================================================
//  仕様
//====================================================================

/*--------------------------------------------------------------------

  手札、場札、チェンジ数、テイク数、捨札を引数とし、捨札を決める。
  返却値は、捨札の位置である。-1のときは、交換しないで、手札を確定させる。
  関数 strategy() は、戦略のインタフェースであり、この関数内で、
  実際の戦略となる関数を呼び出す。手札と捨札は、不正防止のため、
  変更不可なので、局所配列にコピーして、整列などの処理を行う。
  複数の戦略を比較したり、パラメタを変化させて、より強い戦略を目指す。

  ---------------------------------------------------------------------*/


//====================================================================
//  前処理
//====================================================================

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "../../src/Poker.h"

//--------------------------------------------------------------------
//  関数宣言
//--------------------------------------------------------------------



//====================================================================
//  戦略
//====================================================================

/*--------------------------------------------------------------------
//  ユーザ指定
//--------------------------------------------------------------------

最初の手札のまま交換しない。

hd : 手札配列
fd : 場札配列(テイク内の捨札)
cg : チェンジ数
tk : テイク数
ud : 捨札配列(過去のテイクも含めた全ての捨札)
us : 捨札数

--------------------------------------------------------------------*/


//--------------------------------------------------------------------
//  フラッシュの判定
//--------------------------------------------------------------------
int flash_judge( int hd[] )
{
  int hd_rank[5]; //手持ちの数字の判定
  int hd_suite[5]; //模様の判定
  int rank_num[13] = { 0 }; //数字の枚数 ビーンソート
  int suite_num[4] = { 0 }; //模様の枚数

  int k;
  int i, j;


  for( k = 0; k < 5; k++ ) {
    hd_rank[k] = hd[k] % 13;
    hd_suite[k] = hd[k] / 13;

    rank_num[ hd_rank[k] ]++;
    suite_num[ hd_suite[k] ]++;
  }

  /* フラッシュのリーチ判定 */  
  for ( i = 0; i < 4; i++ ) {
    if ( suite_num[i] == 4 ) { //リーチになっているか
      for ( j = 0; j < 4; j++ ) {
        if( suite_num[j] == 1 ) {  //絵柄が違うもの
          for ( k = 0; k < 5; k++ ) { //手札の仲間外れを探す
            if ( hd_suite[k] == j ){
              return k;
            }
          }

        }
      }
    }
  }


  return -1;
}
//--------------------------------------------------------------------
//  ペアの判定
//--------------------------------------------------------------------
int pair_count( int hd[] )
{

  int hd_rank[5]; //手持ちの数字の判定
  int rank_num[13] = { 0 }; //数字の枚数
  int pair = 0;

  int k;
  int i, j;


  for( k = 0; k < 5; k++ ) { //各数字の枚数
    hd_rank[5] = hd[k] % 13;
    rank_num[ hd_rank[k] ]++;
  }

  for ( i = 0; i < 13; i++ ) {
    if( rank_num[i] == 1 ) { //どこともペアにならない場合
      for( j = 0; j < 5; j++ ) { 
        if ( hd_rank[j] == i ) { 
          return j;
        }
      }
    }
  }

  return -1;
}

//--------------------------------------------------------------------
//    ストレートの判定
//--------------------------------------------------------------------
int straight( int hd[] )
{
  int hd_rank[5]; //手持ちの数字の判定
  int rank_num[13] = { 0 }; //数字の枚数
  int reach[13] = { 0 }; //リーチの数字
  int k, i;

  for( k = 0; k < 5; k++ ) { //各数字の枚数
    hd_rank[k] = hd[k] % 13;
    rank_num[ hd_rank[k] ]++;
  }

  //順番に揃っているとき
  // ○●●●●○
  for ( k = 0; k < 11; k++ ) {

    if( rank_num[k] > 0 && rank_num[k + 1] > 0 && rank_num[k + 2] > 0 && rank_num[(k + 3) % 13] > 0 ) {  // %13でもし9 10 11 12 1が出る時の場合もOKに
      for ( i = 0; i < 5; i++ ) {                                                                        // k = 9 10 11 12 13の時↑

        if ( hd_rank[i] != k && hd_rank[i] != k + 1 && hd_rank[i] != k + 2 && hd_rank[i] != ( k + 3 ) % 14 ) { //並んでいる数でないときi番目の手札のチェンジ

          return i;
        }
      }
    }
  }

  //間が1つ空いているとき
  // ●○●●●
  for ( k = 0; k < 10; k++ ) {
    if( rank_num[k] > 0 && rank_num[k + 2] > 0 && rank_num[k + 3] > 0 && rank_num[(k + 4) % 13] > 0 ) {
      for ( i = 0; i < 5; i++ ) {
        if ( hd_rank[i] != k && hd_rank[i] != k + 2 && hd_rank[i] != k + 3 && hd_rank[i] != ( k + 4 ) % 13 ) {
          return i;
        }
      }
    }
  }

  //●●○●●
  for ( k = 0; k < 10; k++ ) {
    if( rank_num[k] > 0 && rank_num[k + 1] > 0 && rank_num[k + 3] > 0 && rank_num[(k + 4) % 13] > 0 ) {
      for ( i = 0; i < 5; i++ ) {
        if ( hd_rank[i] != k && hd_rank[i] != k + 1 && hd_rank[i] != k + 3 && hd_rank[i] != ( k + 4 ) % 13 ) {
          return i;
        }
      }
    }
  }

  //●●●○●
  for ( k = 0; k < 10; k++ ) {
    if( rank_num[k] > 0 && rank_num[k + 1] > 0 && rank_num[k + 2] > 0 && rank_num[(k + 4) % 13] > 0 ) {
      for ( i = 0; i < 5; i++ ) {
        if ( hd_rank[i] != k && hd_rank[i] != k + 1 && hd_rank[i] != k + 2 && hd_rank[i] != ( k + 4 ) % 13 ) {
          return i;
        }
      }
    }
  }


  return -1;
}

int strategy( int hd[], int fd[], int cg, int tk, int ud[], int us) {
  int myhd[HNUM];
  int select = -1;
  int point;

  int i;


  //高い役の時終了
  point = poker_point( hd ); //手札の点数
  if ( point == P9 ) { return -1; } //ロイヤルストレートフラッシュ
  if ( point == P8 ) { return -1; } //ストレートフラッシュ
  if ( point == P7 ) { return -1; } //フォーカード
  if ( point == P5 ) { return -1; } //フラッシュ
  if ( point == P6 ) { return -1; } //フルハウス
  if ( point == P4 ) { return -1; } //ストレート

  //フラッシュ     
  select = flash_judge( hd );

  if ( select != -1 ) {
    return select;
  }

  //ストレート
  select = straight( hd );
  if ( select >= 0 ) { return select; }

  //ペア  
  select = pair_count( hd );
  return select; //-1=交換を止める

  return -1;
}

//====================================================================
//  補助関数
//====================================================================

